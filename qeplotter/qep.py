"""
QEPlotter — Quantum ESPRESSO Band and Fatband Visualization Toolkit
===================================================================

QEPlotter is an open-source, user-friendly Python library for visualizing
band structures and fatbands from Quantum ESPRESSO calculations.

Key Features:
-------------
- Read and plot Quantum ESPRESSO band structure files (.bands.dat.gnu), k-point paths, and fatband/projwfc files.
- Support for multiple fatband coloring and grouping modes:
    * By atom (element-projected)
    * By orbital (s, p, d, etc.)
    * By element-orbital channel
- Automatic detection of band path segments and high-symmetry points.
- Total DOS and projected DOS plotting.
- All plots are automatically saved in a user-defined format (PNG, PDF, ...), organized in a "saved" folder.
- Easy integration in Python scripts or Jupyter notebooks.

Typical Usage:
--------------
from qeplotter import plot_from_file

plot_from_file(
    plot_type='fatbands',
    band_file='bands.dat.gnu',
    fatband_dir='fatband_dir',
    kpath_file='kpath.in',
    fatbands_mode='atomic',
    savefig='my_fatband.pdf'
)

Requirements:
-------------
- numpy
- matplotlib


"""

import os
import glob
import re
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.collections as mcoll


def strip_number(atom_label):
    return re.sub(r"\d+$", "", atom_label)

# ==============================
# K-POINTS / BAND READING UTILS
# ==============================

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
SCRIPT_DIR = os.path.dirname(SCRIPT_DIR)
def parse_kpath_file(kpath_file):
    """
    Parses a Quantum ESPRESSO K_POINTS (crystal_b) file to extract the number of k-points
    for each path segment and the corresponding high-symmetry point labels.

    Parameters
    ----------
    kpath_file : str
        Path to the QE K_POINTS file (crystal_b format).

    Returns
    -------
    counts : list of int
        Number of k-points for each segment (i.e., between high-symmetry points).
    labels : list of str
        List of high-symmetry point labels in the path (e.g., 'G', 'K', 'M').

    Notes
    -----
    The function skips the last row of the K_POINTS file. This is intentional:
      - The last row typically only repeats the initial high-symmetry point to close the band path.
      - If you do NOT skip the last row, the code would count one more segment than actually exists,
        which leads to tick and segment misalignment in plotting.

    Example
    -------
    Given a file like:
        K_POINTS crystal_b
        4
          0.0000  0.0000  0.0  20  ! G
          0.5000  0.0000  0.0  30  ! M
          0.3333  0.3333  0.0  40  ! K
          0.0000  0.0000  0.0  20  ! G
    Output will be:
        counts = [20, 30, 40]
        labels = ['G', 'M', 'K']
    """
    counts, labels = [], []
    with open(kpath_file, 'r') as f:
        lines = f.readlines()
    start = None
    for i, line in enumerate(lines):
        if line.strip().upper().startswith('K_POINTS'):
            start = i + 2
            break
    if start is None or start >= len(lines):
        raise ValueError(f"K_POINTS header not found or invalid in {kpath_file}")
    n_lines = len(lines[start:])
    for idx, line in enumerate(lines[start:]):

        if idx == n_lines - 1:
            continue
        txt = line.strip()
        if not txt or txt.startswith('#'):
            continue
        parts = txt.split('!')
        vals = parts[0].split()
        try:
            cnt = int(vals[3])
        except Exception:
            cnt = 1
        lbl = parts[1].strip() if len(parts) > 1 else ''
        counts.append(cnt)
        labels.append(lbl)
    return counts, labels


def read_band_xdistances(band_file, kpath_file):
    """
    Reads a Quantum ESPRESSO .bands.dat.gnu band file and a K_POINTS path file,
    and extracts all x-axis distances, band energies, tick locations, and segment ranges for plotting.

    Parameters
    ----------
    band_file : str
        Path to the QE .bands.dat.gnu file (typically generated by bands.x).
    kpath_file : str
        Path to the QE K_POINTS file in crystal_b format (see parse_kpath_file).

    Returns
    -------
    x_dist : np.ndarray, shape (N_k,)
        Distance along the k-path for each k-point (for x-axis).
    band_energies : np.ndarray, shape (N_bands, N_k)
        Energies for all bands at each k-point.
    tick_positions : list of float
        x-coordinates of high-symmetry points (used for vertical tick lines).
    tick_labels : list of str
        Corresponding labels for each tick (e.g., 'G', 'K', 'M', ...).
    seg_ranges : list of (int, int)
        Index ranges (start, end) for each band path segment.

    How it works
    ------------
    - The .bands.dat.gnu file consists of blocks of numbers separated by empty lines.
      Each block represents a single band: the first column is the x-distance,
      the second is the band energy at each k-point along the path.
    - All band blocks must contain the same number of k-points (N_k).
    - The k-path file provides the number of k-points in each segment, and the
      names of the high-symmetry points (see parse_kpath_file).

    Special Notes
    -------------
    - If the total k-point count in the bands file and the k-path file does not match,
      the function tries to correct for off-by-one errors, but will print a warning if mismatched.
    - If the input files are inconsistent (e.g., wrong path or missing data), a ValueError is raised.

    Example
    -------
    (Suppose .bands.dat.gnu encodes 90 k-points and 12 bands, kpath_file gives three segments.)

    x_dist, band_energies, tick_positions, tick_labels, seg_ranges = read_band_xdistances(
        band_file='bands.dat.gnu', kpath_file='kpath.in'
    )

    # x_dist: 1D numpy array of shape (90,)
    # band_energies: 2D array of shape (12, 90)
    # tick_positions: list of floats (one for each high-symmetry point)
    # tick_labels:    list of labels ('G', 'K', ...)
    # seg_ranges:     list of (start, end) index pairs for each path segment
    """
    # 1) read all lines and group into blocks
    with open(band_file, 'r') as f:
        raw = f.read().splitlines()
    blocks = []
    block = []
    for line in raw:
        if line.strip() == "":
            if block:
                blocks.append(block)
                block = []
        else:
            block.append(line)
    if block:
        blocks.append(block)

    # 2) parse each block
    band_arrays = []
    for blk in blocks:
        try:
            arr = np.loadtxt(blk)
        except Exception as e:
            raise ValueError(f"Failed to parse band block: {e}")
        if arr.ndim != 2 or arr.shape[1] < 2:
            raise ValueError(f"Unexpected block shape {arr.shape}")
        band_arrays.append(arr)

    if not band_arrays:
        raise ValueError(f"No bands found in {band_file}")

    # 3) ensure all blocks have same length
    lengths = [b.shape[0] for b in band_arrays]
    if len(set(lengths)) != 1:
        raise ValueError(f"Inconsistent k-points per band: {lengths}")
    N_k = lengths[0]

    # 4) extract x_dist and energies
    x_dist = band_arrays[0][:, 0].copy()
    band_energies = np.vstack([b[:, 1] for b in band_arrays])


    # 5) parse kpath
    counts, labels = parse_kpath_file(kpath_file)
    cum = np.cumsum([0] + counts)
    if cum[-1] != N_k:
        # adjust only by ±1, else warn
        if cum[-1] == N_k + 1:
            cum[-1] = N_k
        elif cum[-1] == N_k - 1:
            cum = np.append(cum, N_k)
            labels = labels + [labels[0] if labels else ""]
        else:
            print(f"Warning: sum(counts)={cum[-1]} != N_k={N_k}. Tick positions may be misaligned.")

    tick_positions = []
    tick_labels = []
    for idx, lbl in zip(cum, labels + [""]):
        if idx >= N_k:
            break
        tick_positions.append(x_dist[idx])
        tick_labels.append(lbl)

    # segment boundaries
    dx = np.diff(x_dist)
    breaks = np.where(dx < -1e-6)[0]
    seg_ranges = []
    start = 0
    for br in breaks:
        seg_ranges.append((start, br))
        start = br + 1
    seg_ranges.append((start, N_k - 1))

    return x_dist, band_energies, tick_positions, tick_labels, seg_ranges
# FATBAND FILE READING
# ==============================

def read_fatband_files(directory):
    """
    Plots a band structure from a QE .bands.dat.gnu file.
    Optionally colors the bands using projections (fatband mode), if provided.

    Parameters
    ----------
    band_file : str
        Path to band structure file (.bands.dat.gnu).
    kpath_file : str
        Path to k-path (K_POINTS crystal_b) file.
    fermi_level : float or None
        If set, the Fermi level is drawn as a horizontal dashed line.
    shift_fermi : bool
        If True, all energies are shifted so the Fermi level is at 0 eV.
    y_range : tuple or None
        Y-axis (energy) limits for the plot.
    dpi : int or None
        Plot DPI for saving or display.
    band_mode : str
        Band coloring mode: 'normal' (default, black lines), or
        'atomic', 'orbital', 'element_orbital', 'most' (requires fatband_dir).
    fatband_dir : str or None
        If using a projection coloring mode, provide the directory containing PDOS/fatband files.
    cmap_name : str
        Name of the matplotlib colormap.
    savefig : str or None
        If provided, saves the figure to a file (in ./saved/ subfolder).

    Notes
    -----
    - This function is mostly for standalone band structure plots.
    - For full fatband bubble or line plots, use `plot_fatbands`.

    Example
    -------
    plot_band(
        band_file='bands.dat.gnu',
        kpath_file='kpath.in',
        fermi_level=-5.35,
        shift_fermi=True,
        band_mode='atomic',
        fatband_dir='my_fatband_dir',
        savefig='band_atomic.pdf'
    )
    """


    # Pattern to extract atom number, element, and orbital from filename
    pattern = re.compile(r'atm#(\d+)\(([A-Za-z]+)\)_wfc#\d+\(([spdfgpxyz]+)\)')
    # Fallback for just element/orbital if atom number not present
    fallback = re.compile(r'atm#\d+\(([A-Za-z]+)\)_wfc#\d+\(([spdfgpxyz]+)\)')

    file_list = sorted(glob.glob(os.path.join(directory, '*pdos*')))
    if not file_list:
        raise FileNotFoundError(f"No fatband files matching '*pdos*' found in {directory}")
    labels = []
    ik0 = None
    E0 = None
    W_list = []
    N_k = None
    N_e = None
    # First pass: read all files
    for fn in file_list:
        base = os.path.basename(fn)
        m = pattern.search(base)
        if m:
            atom_num = m.group(1)
            elem     = m.group(2)
            orb      = m.group(3)
            atom_label = f"{elem}{atom_num}"  # e.g. 'Mo2', 'W1', 'S3'
            labels.append((atom_label, orb))
        else:
            m2 = fallback.search(base)
            if m2:
                elem, orb = m2.group(1), m2.group(2)
                labels.append((elem, orb))
            else:
                labels.append(('?', '?'))
        # Load data
        try:
            data = np.loadtxt(fn, comments='#')
        except Exception as e:
            raise ValueError(f"Failed to load {fn}: {e}")
        if data.ndim != 2 or data.shape[1] < 3:
            raise ValueError(f"Unexpected format in fatband file {fn}: need ≥3 columns, got {data.shape}")
        ik = data[:, 0].astype(int)
        E = data[:, 1]
        w = data[:, 2]
        # On first file, record ik0/E0 to deduce grid shape
        if ik0 is None:
            ik0 = ik.copy()
            E0 = E.copy()
            uniq_ik = np.unique(ik0)
            N_k = len(uniq_ik)
            counts = [np.count_nonzero(ik0 == kval) for kval in uniq_ik]
            N_e0 = counts[0]
            if not all(c == N_e0 for c in counts):
                N_e = min(counts)
                print(f"Warning: varying rows per k in first file: counts={counts[:5]}..., truncating to N_e={N_e}")
            else:
                N_e = N_e0
        else:
            # Validate ik structure roughly matches first file
            uniq_ik_i = np.unique(ik)
            if len(uniq_ik_i) != N_k:
                raise ValueError(f"File {fn}: unique ik count {len(uniq_ik_i)} != expected {N_k}")
            counts_i = [np.count_nonzero(ik == kval) for kval in uniq_ik_i]
            if not all(c == counts_i[0] for c in counts_i):
                min_e = min(counts_i)
                print(f"Warning: file {fn} has varying rows per k, will truncate to min {min_e}")
                N_e = min(N_e, min_e)
            else:
                if counts_i[0] != N_e:
                    N_e = min(N_e, counts_i[0])
        W_list.append((ik, E, w))
    # Build grids truncated to N_e
    uniq_ik = np.unique(ik0)
    N_k = len(uniq_ik)
    # Build E_grid from first file
    E_grid = np.zeros((N_k, N_e))
    for i, kval in enumerate(uniq_ik):
        idxs = np.where(ik0 == kval)[0][:N_e]
        if len(idxs) < N_e:
            raise ValueError(f"Not enough rows for ik={kval} in first file: got {len(idxs)}, expected {N_e}")
        E_grid[i, :] = E0[idxs]
    # Build W_grids
    W_grids = []
    for ik, E, w in W_list:
        arr = np.zeros((N_k, N_e))
        for i, kval in enumerate(uniq_ik):
            idxs = np.where(ik == kval)[0][:N_e]
            if len(idxs) < N_e:
                raise ValueError(f"Not enough rows for ik={kval} in fatband file: got {len(idxs)}, expected {N_e}")
            arr[i, :] = w[idxs]
        W_grids.append(arr)
    return labels, uniq_ik, E_grid, W_grids

# ==============================
# PLOTTING FUNCTIONS
# ==============================

def plot_band(
    band_file,
    kpath_file,
    fermi_level=None,
    shift_fermi=False,
    y_range=None,
    dpi=None,
    band_mode='normal',
    fatband_dir=None,
    cmap_name='tab10',
        savefig=None
):
    """
       Plot the electronic band structure from Quantum ESPRESSO.

       Parameters
       ----------
       band_file : str
           Path to the QE band structure file (.bands.dat.gnu).
       kpath_file : str
           Path to the K_POINTS (crystal_b) file (for k-path and symmetry labels).
       fermi_level : float, optional
           Fermi energy (in eV). If given, can shift the energy axis.
       shift_fermi : bool, optional
           If True, shifts all energies so the Fermi level is at 0 eV.
       y_range : tuple or list, optional
           (ymin, ymax) limits for the energy axis.
       dpi : int, optional
           Output resolution (dots per inch) for the plot.
       band_mode : str, optional
           Plot style:
             - 'normal': plain band lines (default)
             - 'atomic', 'orbital', 'element_orbital', 'most': color bands by dominant channel
           If using a colored mode, fatband_dir must be provided.
       fatband_dir : str, optional
           Directory with projection (fatband) files, required for colored band modes.
       cmap_name : str, optional
           Name of the matplotlib colormap for colored bands.
       savefig : str, optional
           Filename for saving the plot. If None, the plot is only displayed.

       Returns
       -------
       None. Displays (and optionally saves) the band structure plot.
       """
    # 1) Read band data
    x_dist, band_energies, tick_positions, tick_labels, seg_ranges = read_band_xdistances(band_file, kpath_file)
    N_k = x_dist.shape[0]

    if shift_fermi and fermi_level is not None:
        band_energies = band_energies - fermi_level


    if dpi is not None:
        plt.figure(figsize=(8,6), dpi=dpi)
    else:
        plt.figure(figsize=(8,6))


    if band_mode == 'normal' or band_mode is None:
        for band in band_energies:
            for (s,e) in seg_ranges:
                if e > s:
                    plt.plot(x_dist[s:e+1], band[s:e+1], 'k-', lw=1)
                else:
                    plt.plot(x_dist[s], band[s], 'k.', markersize=2)
        title = 'Band Structure'
    else:

        if fatband_dir is None:
            raise ValueError(f"band_mode='{band_mode}' requires fatband_dir with projection files")
        # 2) Read fatband projection grids
        labels, uniq_ik, E_grid, W_grids = read_fatband_files(fatband_dir)

        if len(uniq_ik) != N_k:
            print(f"Warning: fatband N_k={len(uniq_ik)} vs band file N_k={N_k}. They should match for correct coloring.")

          # strip off the atom numbers so all 'Bi1','Bi2',... become just 'Bi'
        ch_labels = [f"{strip_number(a)}-{o}" for (a, o) in labels]
        elems = [strip_number(a) for (a, _) in labels]
        orbs  = [o for (_,o) in labels]

        if band_mode == 'atomic':
            unique_keys = sorted(set(elems))

            group_indices = {key: [i for i,a in enumerate(elems) if a==key] for key in unique_keys}
        elif band_mode == 'orbital':
            unique_keys = sorted(set(orbs))
            group_indices = {key: [i for i,o in enumerate(orbs) if o==key] for key in unique_keys}
        elif band_mode in ('element_orbital', 'most'):
            unique_keys = sorted(set(ch_labels))
            group_indices = {key: [i for i,lab in enumerate(ch_labels) if lab==key] for key in unique_keys}
        else:
            raise ValueError(f"Unknown band_mode: {band_mode}")

        # 3) For each band, determine dominant group:
        nbands = band_energies.shape[0]
        band_colors = [None]*nbands

        cmap = cm.get_cmap(cmap_name, len(unique_keys))

        for b in range(nbands):

            group_sums = {key: 0.0 for key in unique_keys}

            k_iter = min(N_k, E_grid.shape[0])
            for i in range(k_iter):
                Eb = band_energies[b,i]

                if shift_fermi and fermi_level is not None:
                    row = E_grid[i,:] - fermi_level
                else:
                    row = E_grid[i,:]

                if row.size == 0:
                    continue
                j = np.argmin(np.abs(row - Eb))

                for key, idx_list in group_indices.items():

                    try:
                        wvals = [W_grids[idx][i,j] for idx in idx_list]
                    except Exception:

                        continue
                    group_sums[key] += np.sum(wvals)

            sums = np.array([group_sums[k] for k in unique_keys])
            if sums.sum() <= 0:
                color = 'k'
            else:
                imax = np.argmax(sums)
                color = cmap(imax)
            band_colors[b] = color

        # 4) Plot each band with its color
        for b, band in enumerate(band_energies):
            col = band_colors[b]
            for (s,e) in seg_ranges:
                if e > s:
                    y = band[s:e+1]
                    x = x_dist[s:e+1]
                    plt.plot(x, y, color=col, lw=1)
                else:
                    plt.plot(x_dist[s], band[s], 'o', color=col, markersize=3)
        title = f'Band Structure ({band_mode})'


        for i, key in enumerate(unique_keys):
            plt.plot([], [], color=cmap(i), label=key, lw=3)
        plt.legend(fontsize='small', ncol=2, loc='best')


    for tx in tick_positions:
        plt.axvline(tx, color='gray', ls='--', alpha=0.6)

    if fermi_level is not None:
        y0 = 0.0 if shift_fermi else fermi_level
        plt.axhline(y0, color='r', ls='--', lw=1.2, label=f'Fermi = {fermi_level:.2f} eV')

    plt.xticks(tick_positions, tick_labels)
    plt.xlabel('K-point Path')
    plt.ylabel('Energy (eV)')
    if y_range:
        plt.ylim(y_range)
    plt.title(title)
    plt.grid(True, ls='--', alpha=0.4)
    if fermi_level is not None:
        plt.legend()
    plt.tight_layout()
    if savefig:
        SAVE_DIR = os.path.join(SCRIPT_DIR, "saved")
        os.makedirs(SAVE_DIR, exist_ok=True)
        out = os.path.join(SAVE_DIR, os.path.basename(savefig))
        plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
        print(f"Saved figure to {out}")

    plt.show()

def plot_dos(dos_file, fermi_level=None, shift_fermi=False, y_range=None, dpi=None,
        savefig=None):
    """
    Plot the total Density of States (DOS) from a QE DOS file.

    Parameters
    ----------
    dos_file : str
        Path to the DOS file (columns: energy [eV], total DOS).
    fermi_level : float, optional
        Value of the Fermi energy (in eV). If provided, can be used to shift the plot.
    shift_fermi : bool, optional
        If True, shifts all energies so that the Fermi level appears at 0 eV.
    y_range : tuple or list, optional
        (ymin, ymax) limits for the DOS axis.
    dpi : int, optional
        Output resolution (dots per inch) for the plot.
    savefig : str, optional
        Filename for saving the figure. If None, the plot is only displayed.

    Returns
    -------
    None. Displays (and optionally saves) the DOS plot.
    """
    data = np.loadtxt(dos_file)
    if data.ndim != 2 or data.shape[1] < 2:
        raise ValueError(f"Unexpected DOS file format: {dos_file}")
    E = data[:, 0]
    DOS = data[:, 1]
    if shift_fermi and fermi_level is not None:
        E = E - fermi_level
    if dpi is not None:
        plt.figure(figsize=(6,6), dpi=dpi)
    else:
        plt.figure(figsize=(6,6))
    plt.plot(E, DOS, 'k-', lw=1, label='Total DOS')
    if fermi_level is not None:
        x0 = 0.0 if shift_fermi else fermi_level
        plt.axvline(x0, color='r', ls='--', lw=1.2, label=f'Fermi = {fermi_level:.2f} eV')
    plt.xlabel('Energy (eV)')
    plt.ylabel('DOS')
    if y_range:
        plt.ylim(y_range)
    plt.title('Total DOS')
    plt.grid(True, ls='--', alpha=0.4)
    if fermi_level is not None:
        plt.legend()
    plt.tight_layout()
    if savefig:
        SAVE_DIR = os.path.join(SCRIPT_DIR, "saved")
        os.makedirs(SAVE_DIR, exist_ok=True)
        out = os.path.join(SAVE_DIR, os.path.basename(savefig))
        plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
        print(f"Saved figure to {out}")

    plt.show()

def plot_pdos_dir(pdos_dir, fermi_level=None,
                  shift_fermi=False, y_range=None, dpi=None,pdos_mode='atomic',
        savefig=None):
    """
    Plot projected Density of States (PDOS) from a set of QE projwfc/pdos files.

    Parameters
    ----------
    pdos_dir : str
        Directory containing PDOS files (one for each atom/orbital).
    fermi_level : float, optional
        Fermi energy (in eV). If given, can be used to shift the plot.
    shift_fermi : bool, optional
        If True, shifts all energies so the Fermi level is at 0 eV.
    y_range : tuple or list, optional
        (ymin, ymax) limits for the PDOS axis.
    dpi : int, optional
        Output resolution (dots per inch) for the plot.
    pdos_mode : str, optional
        How to group and sum PDOS channels on the plot:
          - 'atomic': sum all orbitals for each atom type (e.g., all Mo, S, W)
          - 'orbital': sum all atoms for each orbital (e.g., all p, d)
          - 'element_orbital': show each atom-orbital pair separately (e.g., Mo-d, S-p)
    savefig : str, optional
        Filename for saving the figure. If None, the plot is only displayed.

    Returns
    -------
    None. Displays (and optionally saves) the PDOS plot.
    """
    pat = re.compile(r'atm#\d+\(([A-Za-z]+)\)_wfc#\d+\(([spdfgpxyz]+)\)')
    files = glob.glob(os.path.join(pdos_dir, '*pdos*'))
    if not files:
        raise FileNotFoundError(f"No PDOS files found in {pdos_dir}")
    grouped = {}
    E = None
    for fn in files:
        base = os.path.basename(fn)
        m = pat.search(base)
        if not m:
            continue
        elem, orb = m.group(1), m.group(2)
        if pdos_mode == 'atomic':
            key = elem
        elif pdos_mode == 'orbital':
            key = orb
        elif pdos_mode == 'element_orbital':
            key = f"{elem}-{orb}"
        else:
            raise ValueError(f"Unknown pdos_mode: {pdos_mode}")
        data = np.loadtxt(fn, comments='#')
        if data.ndim != 2 or data.shape[1] < 2:
            continue
        if E is None:
            E = data[:, 0].copy()
            if shift_fermi and fermi_level is not None:
                E = E - fermi_level
        pd = data[:, -1]
        grouped.setdefault(key, np.zeros_like(pd))
        grouped[key] += pd
    if not grouped:
        raise RuntimeError("No PDOS channels matched; check filenames and pdos_mode")
    if dpi is not None:
        plt.figure(figsize=(6,6), dpi=dpi)
    else:
        plt.figure(figsize=(6,6))
    for k, pd in sorted(grouped.items()):
        plt.plot(E, pd, lw=1, label=k)
    if fermi_level is not None:
        x0 = 0.0 if shift_fermi else fermi_level
        plt.axvline(x0, color='r', ls='--', lw=1.2, label=f'Fermi = {fermi_level:.2f} eV')
    plt.xlabel('Energy (eV)')
    plt.ylabel('Projected DOS')
    if y_range:
        plt.ylim(y_range)
    plt.title(f'Projected DOS ({pdos_mode})')
    plt.grid(True, ls='--', alpha=0.4)
    plt.legend(fontsize='small', ncol=2)
    plt.tight_layout()
    if savefig:
        SAVE_DIR = os.path.join(SCRIPT_DIR, "saved")
        os.makedirs(SAVE_DIR, exist_ok=True)
        out = os.path.join(SAVE_DIR, os.path.basename(savefig))
        plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
        print(f"Saved figure to {out}")

    plt.show()

def plot_fatbands(
    directory,
    kpath_file,
    band_file,
    mode='most',
    highlight_channel=None,
    dual=False,
    fermi_level=None,
    shift_fermi=False,
    y_range=None,
    cmap_name='tab10',
    s_min=10,
    s_max=100,
    weight_threshold=0.01,
    plot_total_dos=False,
    dos_file=None,
    overlay_bands_in_heat=False,
    heat_vmin=None,
    heat_vmax=None,
    dpi=None,
    layer_assignment=None ,
        savefig=None  # <--- ADDED
):
    """
      Plot fatbands from Quantum ESPRESSO data.

      This function visualizes band structures with atomic/orbital-resolved "fatbands"
      from QE projwfc files, supporting several visualization modes.


Parameters
----------
directory : str
    Directory containing fatband (PDOS/projwfc) files produced by Quantum ESPRESSO.
kpath_file : str
    Path to the QE K_POINTS file in "crystal_b" format (defines k-point path and high-symmetry labels).
band_file : str
    Path to the QE band structure file (usually ends with .bands.dat.gnu).
mode : str, optional
    Visualization mode for fatbands. Controls how channel-resolved information is displayed:
      - 'most', 'atomic', 'orbital', 'element_orbital': Bubble modes (dominant channel per (k,E) as colored bubbles)
      - 'normal', 'o_atomic', 'o_orbital', 'o_element_orbital': Line modes (band color encodes channel fraction)
      - 'heat_total', 'heat_atomic', 'heat_orbital', 'heat_element_orbital': Heatmap modes (background color = channel weight)
      - 'layer': Color bands by layer (requires `layer_assignment`).
highlight_channel : str or list, optional
    Channel(s) to highlight in line/heatmap modes.
      - For 'o_atomic': atom label (e.g., 'Mo', 'W', 'S').
      - For 'o_orbital': orbital label (e.g., 's', 'p', 'd').
      - For 'o_element_orbital': combined label (e.g., 'Mo-d', 'S-p').
      - For dual mode: list/tuple with two channels (e.g., ['Mo', 'S'] or ['d', 'p']).
    Not used in bubble modes.
dual : bool, optional
    If True (with a list of two highlight channels), uses a colorbar to interpolate between the two channels along each band.
    Only for line modes ('o_atomic', etc.). Useful for visualizing smooth mixing between channels.
fermi_level : float, optional
    Value of the Fermi energy (in eV). If set, can be used to shift the band/DOS plots such that the Fermi level is at zero.
shift_fermi : bool, optional
    If True, shifts all band energies and DOS so that the Fermi level appears at 0 eV on the plot.
y_range : tuple or list, optional
    (ymin, ymax) values for the energy axis (eV). Limits the displayed vertical range of the plot.
cmap_name : str, optional
    Name of the matplotlib colormap to use for coloring channels/bands (default: 'tab10').
s_min : float, optional
    Minimum marker size for bubbles or heatmap points (default: 10).
s_max : float, optional
    Maximum marker size for bubbles or heatmap points (default: 100).
weight_threshold : float, optional
    Fraction (0–1) of the global max channel weight to be plotted. Points with lower weight are omitted for clarity.
plot_total_dos : bool, optional
    If True, plots the total DOS (from `dos_file`) alongside the fatbands.
dos_file : str, optional
    Path to the total DOS file (energy, DOS columns), required if `plot_total_dos=True`.
overlay_bands_in_heat : bool, optional
    If True, overlays plain band structure lines on top of heatmap plots for visual reference.
heat_vmin : float, optional
    Minimum value for heatmap color normalization (default: data minimum).
heat_vmax : float, optional
    Maximum value for heatmap color normalization (default: data maximum).
dpi : int, optional
    Output resolution (dots per inch) for the plot figure.
layer_assignment : dict, optional
    Only for 'layer' mode. Dictionary mapping atom names (e.g., 'Mo1', 'S3') to 'top' or 'bottom' layer.
savefig : str, optional
    Filename for saving the generated plot (in a 'saved' directory within your project).
    If not set, the plot is only displayed and not saved.




      Returns
      -------
      None. Plots and saves the figure.

      ----"""


    # --- BUBBLE MODES ---
    # If mode in {'most', 'atomic', 'orbital', 'element_orbital'}:
    #   For each (k, E), show a colored bubble indicating which channel (atom/orbital/element-orbital) is dominant.
    #   Bubble size reflects the absolute weight. Each color = one channel.
    #   Use this to see "where" each atom or orbital dominates in the band structure.

    # --- LINE MODES ---
    # If mode in {'normal', 'o_atomic', 'o_orbital', 'o_element_orbital'}, or dual=True:
    #   Color the band lines themselves, using a colorbar to represent the fraction
    #   of one or two selected channels (e.g., d vs p orbitals, S vs Mo, etc.).
    #   Great for highlighting hybridization and channel mixing.

    # --- HEAT MODES ---
    # If mode in {'heat_total', 'heat_atomic', 'heat_orbital', 'heat_element_orbital'}:
    #   Plot a heatmap-style background showing absolute weights of total or selected channels.
    #   Band lines are overlaid for reference.

    # --- LAYER MODE ---
    # If mode == 'layer':
    #   For multilayer systems, color the bands by the relative contribution of "top" and "bottom" layers.
    #   The layer_assignment dictionary (atom: "top"/"bottom") is required.


    # Example usage comments for developers:
    #
    #   mode='o_atomic', highlight_channel='Mo'      # Color band lines by Mo atom fraction
    #   mode='o_orbital', highlight_channel='d'      # Color by d orbital contribution
    #   mode='o_element_orbital', highlight_channel='Mo-d' # Color by Mo-d orbital
    #   mode='o_atomic', highlight_channel=['Mo', 'S'], dual=True    # Color scale from Mo to S atoms
    #   mode='o_orbital', highlight_channel=['d', 'p'], dual=True    # Color scale from d to p orbitals
    #   mode='heat_atomic', highlight_channel='S'    # Heatmap of S atom weight
    #
    # Notes:
    #   - 'highlight_channel' must match a valid atom/orbital/element-orbital present in your system.
    #   - For dual coloring, highlight_channel should be a list/tuple of length 2.
    #   - Bubble modes ('atomic', etc.) ignore highlight_channel and color by dominant channel at each point.
    #   - 'layer' mode uses the 'layer_assignment' dict instead.

    labels, uniq_ik, E_grid, W_grids = read_fatband_files(directory)
    N_k, N_e = E_grid.shape
    if shift_fermi and fermi_level is not None:
        E_grid = E_grid - fermi_level
    x_dist, band_energies, tick_positions, tick_labels, seg_ranges = read_band_xdistances(band_file, kpath_file)
    if len(x_dist) != N_k:
        print(f"Warning: fatband N_k={N_k} vs band file x_dist length={len(x_dist)}. They should match.")
    if plot_total_dos:
        if dos_file is None:
            raise ValueError("dos_file must be provided when plot_total_dos=True")
        dos_data = np.loadtxt(dos_file)
        if dos_data.ndim != 2 or dos_data.shape[1] < 2:
            raise ValueError(f"Unexpected DOS file format: {dos_file}")
        E_dos = dos_data[:,0]
        DOS   = dos_data[:,1]
        if shift_fermi and fermi_level is not None:
            E_dos = E_dos - fermi_level
    if mode == 'layer':
        atom_name_fn = lambda x: x  # Numara da kullanılır
    else:
        atom_name_fn = strip_number  # Sadece element adı

    elems = [atom_name_fn(a) for (a, _) in labels]
    orbs = [o for (_, o) in labels]
    ch_labels = [f"{atom_name_fn(a)}-{o}" for (a, o) in labels]
    bubble_modes = {'most','atomic','orbital','element_orbital'}
    line_modes = {'normal','o_atomic','o_orbital','o_element_orbital'}
    heat_modes = {'heat_total','heat_atomic','heat_orbital','heat_element_orbital'}


    if mode in bubble_modes:
        # Build grouped weights Wg
        if mode == 'atomic':
            unique_keys = sorted(set(elems))
            Wg = np.zeros((len(unique_keys), N_k, N_e))
            for i, key in enumerate(unique_keys):
                for idx, a in enumerate(elems):
                    if a == key:
                        Wg[i] += W_grids[idx]
        elif mode == 'orbital':
            unique_keys = sorted(set(orbs))
            Wg = np.zeros((len(unique_keys), N_k, N_e))
            for i, key in enumerate(unique_keys):
                for idx, o in enumerate(orbs):
                    if o == key:
                        Wg[i] += W_grids[idx]
        elif mode == 'element_orbital':
            unique_keys = sorted(set(ch_labels))
            Wg = np.zeros((len(unique_keys), N_k, N_e))
            for i, key in enumerate(unique_keys):
                for idx, lab in enumerate(ch_labels):
                    if lab == key:
                        Wg[i] += W_grids[idx]
        else:  # 'most'
            unique_keys = sorted(set(ch_labels))
            Wg = np.zeros((len(unique_keys), N_k, N_e))
            for i, key in enumerate(unique_keys):
                for idx, lab in enumerate(ch_labels):
                    if lab == key:
                        Wg[i] += W_grids[idx]
        # Determine dominant channel and weight
        idx_max = np.argmax(Wg, axis=0)  # shape (N_k, N_e)
        val_max = np.max(Wg, axis=0)
        # Flatten
        X_flat = np.repeat(x_dist, N_e)
        E_flat = E_grid.flatten()
        idx_flat = idx_max.flatten()
        val_flat = val_max.flatten()
        # Threshold
        global_max = np.nanmax(val_flat)
        thr = weight_threshold * global_max
        mask = val_flat > thr
        X_plot = X_flat[mask]
        E_plot = E_flat[mask]
        idx_plot = idx_flat[mask]
        val_plot = val_flat[mask]
        # Colors/sizes
        cmap = cm.get_cmap(cmap_name, len(unique_keys))
        colors = [cmap(i) for i in idx_plot]
        sizes = s_min + (s_max - s_min) * (val_plot / global_max if global_max>0 else 0)
        # Setup figure
        if plot_total_dos:
            if dpi is not None:
                fig, (ax1, ax2) = plt.subplots(1,2, gridspec_kw={'width_ratios':[3,1]}, figsize=(10,6), dpi=dpi, sharey=True)
            else:
                fig, (ax1, ax2) = plt.subplots(1,2, gridspec_kw={'width_ratios':[3,1]}, figsize=(10,6), sharey=True)
        else:
            if dpi is not None:
                fig, ax1 = plt.subplots(1,1,figsize=(8,6), dpi=dpi)
            else:
                fig, ax1 = plt.subplots(1,1,figsize=(8,6))
            ax2 = None
        # Scatter
        ax1.scatter(X_plot, E_plot, s=sizes, c=colors, edgecolor='k', lw=0.3, alpha=0.8, zorder=1)
        # Overlay band lines (split segments)
        for band in band_energies:
            for (s,e) in seg_ranges:
                if e > s:
                    y = band[s:e+1]
                    x = x_dist[s:e+1]
                    if shift_fermi and fermi_level is not None:
                        y = y - fermi_level
                    ax1.plot(x, y, color='gray', lw=0.5, zorder=0)
                else:
                    x = x_dist[s:s+1]
                    y = band[s:s+1]
                    if shift_fermi and fermi_level is not None:
                        y = y - fermi_level
                    ax1.plot(x, y, 'o', color='gray', markersize=2, zorder=0)
        ax1.set_xticks(tick_positions)
        ax1.set_xticklabels(tick_labels)
        ax1.set_xlabel('K-point Path')
        ax1.set_ylabel('Energy (eV)')
        if y_range:
            ax1.set_ylim(y_range)
        title_mode = mode.capitalize() if mode!='most' else 'Most'
        ax1.set_title(f'Fatbands ({title_mode})')
        # Legend
        for i, key in enumerate(unique_keys):
            ax1.scatter([], [], c=[cmap(i)], label=key, edgecolor='k', lw=0.3)
        ax1.legend(fontsize='small', ncol=2, loc='best')
        ax1.grid(True, ls='--', alpha=0.3)
        # Total DOS panel
        if plot_total_dos:
            ax2.plot(DOS, E_dos, 'k-', lw=1)
            ax2.set_xlabel('DOS')
            if y_range:
                ax2.set_ylim(y_range)
            ax2.axvline(0, color='gray', ls='--', lw=0.8)
            ax2.grid(True, ls='--', alpha=0.3)
        plt.tight_layout()
        if savefig:
            SAVE_DIR = os.path.join(SCRIPT_DIR, "saved")
            os.makedirs(SAVE_DIR, exist_ok=True)
            out = os.path.join(SAVE_DIR, os.path.basename(savefig))
            plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
            print(f"Saved figure to {out}")

        plt.show()


    elif mode in line_modes or mode == 'layer':



        if mode == 'layer':

            atom_name_fn = lambda x: x

        else:

            atom_name_fn = strip_number

        elems = []

        orbs = []

        ch_labels = []

        for label in labels:
            elem, orb = label

            elems.append(atom_name_fn(elem))

            orbs.append(orb)

            ch_labels.append(f"{atom_name_fn(elem)}-{orb}")

        if mode == 'layer':
            # 1. Unique atom names from labels (now like 'W1', 'Mo2', 'S3' ...)
            atom_names = sorted(set(a for (a, _) in labels))

            # 2. Use provided assignment, raise if not provided or incomplete
            if layer_assignment is None:
                raise ValueError("You must provide layer_assignment as a dict when using mode='layer'.")

            # 3. Validate all atoms are in assignment
            for atom in atom_names:
                if atom not in layer_assignment:
                    raise ValueError(f"layer_assignment is missing entry for atom '{atom}'. "
                                     f"Please supply all atoms: {atom_names}")

            # 4. Sum weights by layer
            W_top = np.zeros((N_k, N_e))
            W_bottom = np.zeros((N_k, N_e))
            for i, (a, o) in enumerate(labels):
                if layer_assignment[a] == 'top':
                    W_top += W_grids[i]
                elif layer_assignment[a] == 'bottom':
                    W_bottom += W_grids[i]
                else:
                    raise ValueError(
                        f"layer_assignment for atom '{a}' must be 'top' or 'bottom', not '{layer_assignment[a]}'.")

            W_sum = W_top + W_bottom
            W_sum[W_sum <= 0] = np.nan
            frac = W_top / W_sum  # 1 = all top, 0 = all bottom
            colorbar_label = 'Fraction of Top Layer (0=Bottom, 1=Top)'

        elif mode in line_modes:

            if dual:

                if isinstance(highlight_channel, str):

                    groups = [g.strip() for g in highlight_channel.split(',')]

                elif isinstance(highlight_channel, (list, tuple)):

                    groups = list(highlight_channel)

                else:

                    raise ValueError(

                        "For dual=True, highlight_channel must be 'g1,g2' or a two-element list/tuple"

                    )

                if len(groups) != 2:
                    raise ValueError(f"dual mode needs exactly two groups, got {groups!r}")

                key1, key2 = groups

                if mode == 'o_atomic':

                    valid = sorted(set(elems))

                elif mode == 'o_orbital':

                    valid = sorted(set(orbs))

                else:

                    valid = sorted(set(ch_labels))

                if key1 not in valid or key2 not in valid:
                    raise ValueError(f"dual keys {groups!r} must be among {valid}")

                W1 = np.zeros((N_k, N_e))

                W2 = np.zeros((N_k, N_e))

                if mode == 'o_atomic':

                    for i, a in enumerate(elems):

                        if a == key1:
                            W1 += W_grids[i]

                        elif a == key2:
                            W2 += W_grids[i]

                elif mode == 'o_orbital':

                    for i, o in enumerate(orbs):

                        if o == key1:
                            W1 += W_grids[i]

                        elif o == key2:
                            W2 += W_grids[i]

                else:

                    for i, lab in enumerate(ch_labels):

                        if lab == key1:
                            W1 += W_grids[i]

                        elif lab == key2:
                            W2 += W_grids[i]

                W12 = W1 + W2

                W12_safe = W12.copy()

                W12_safe[W12_safe <= 0] = np.nan

                frac = W2 / W12_safe

                colorbar_label = f'Fraction of {key2}   (0={key1}, 1={key2})'

            else:

                if mode == 'o_atomic':

                    if highlight_channel is None:
                        raise ValueError("highlight_channel must be provided for o_atomic mode")

                    unique_atoms = sorted(set(elems))

                    if highlight_channel not in unique_atoms:
                        raise ValueError(f"highlight_channel '{highlight_channel}' not in atomic keys {unique_atoms}")

                    Wtot = np.zeros((N_k, N_e));
                    Whigh = np.zeros((N_k, N_e))

                    for idx, a in enumerate(elems):

                        Wtot += W_grids[idx]

                        if a == highlight_channel:
                            Whigh += W_grids[idx]

                elif mode == 'o_orbital':

                    if highlight_channel is None:
                        raise ValueError("highlight_channel must be provided for o_orbital mode")

                    unique_orbs = sorted(set(orbs))

                    if highlight_channel not in unique_orbs:
                        raise ValueError(f"highlight_channel '{highlight_channel}' not in orbital keys {unique_orbs}")

                    Wtot = np.zeros((N_k, N_e));
                    Whigh = np.zeros((N_k, N_e))

                    for idx, o in enumerate(orbs):

                        Wtot += W_grids[idx]

                        if o == highlight_channel:
                            Whigh += W_grids[idx]

                elif mode == 'o_element_orbital':

                    if highlight_channel is None:
                        raise ValueError("highlight_channel must be provided for o_element_orbital mode")

                    unique_eo = sorted(set(ch_labels))

                    if highlight_channel not in unique_eo:
                        raise ValueError(
                            f"highlight_channel '{highlight_channel}' not in element-orbital keys {unique_eo}")

                    Wtot = np.zeros((N_k, N_e));
                    Whigh = np.zeros((N_k, N_e))

                    for idx, lab in enumerate(ch_labels):

                        Wtot += W_grids[idx]

                        if lab == highlight_channel:
                            Whigh += W_grids[idx]

                else:  # normal

                    Wtot = np.ones((N_k, N_e))

                    Whigh = np.zeros((N_k, N_e))

                Wtot_safe = Wtot.copy()

                Wtot_safe[Wtot_safe <= 0] = np.nan

                frac = Whigh / Wtot_safe

                colorbar_label = f'Fraction of {highlight_channel}'

        # ------ PLOTTING PART (shared for all line/layer modes) ------

        cmap = plt.get_cmap(cmap_name)

        norm = plt.Normalize(0.0, 1.0)

        nbands = band_energies.shape[0]

        if plot_total_dos:

            if dpi is not None:

                fig, (ax1, ax2) = plt.subplots(1, 2, gridspec_kw={'width_ratios': [3, 1]},

                                               figsize=(10, 6), dpi=dpi, sharey=True)

            else:

                fig, (ax1, ax2) = plt.subplots(1, 2, gridspec_kw={'width_ratios': [3, 1]},

                                               figsize=(10, 6), sharey=True)

        else:

            if dpi is not None:

                fig, ax1 = plt.subplots(1, 1, figsize=(8, 6), dpi=dpi)

            else:

                fig, ax1 = plt.subplots(1, 1, figsize=(8, 6))

            ax2 = None

        for b in range(nbands):

            y_line = band_energies[b].copy()

            if shift_fermi and fermi_level is not None:
                y_line = y_line - fermi_level

            x_line = x_dist

            for (s, e) in seg_ranges:

                if e <= s:
                    continue

                xs = x_line[s:e + 1];
                ys = y_line[s:e + 1]

                points = np.array([xs, ys]).T.reshape(-1, 1, 2)

                segments = np.concatenate([points[:-1], points[1:]], axis=1)

                frac_vals = []

                for i_k in range(s, e + 1):

                    Eb = band_energies[b, i_k]

                    Eb0 = Eb - fermi_level if (shift_fermi and fermi_level is not None) else Eb

                    row = E_grid[i_k, :]

                    j = np.argmin(np.abs(row - Eb0))

                    fv = frac[i_k, j]

                    if np.isnan(fv): fv = 0.0

                    frac_vals.append(fv)

                frac_seg = 0.5 * (np.array(frac_vals[:-1]) + np.array(frac_vals[1:]))

                lc = mcoll.LineCollection(segments, array=frac_seg, cmap=cmap,

                                          norm=norm, linewidth=2, zorder=1)

                ax1.add_collection(lc)

        ax1.set_xticks(tick_positions)

        ax1.set_xticklabels(tick_labels)

        ax1.set_xlabel('K-point Path')

        ax1.set_ylabel('Energy (eV)')

        if y_range:
            ax1.set_ylim(y_range)

        if mode == 'layer':

            ax1.set_title('Fatbands (Layer)')

        else:

            title_mode = mode if mode != 'normal' else f"Highlight {highlight_channel}"

            ax1.set_title(f'Fatbands ({title_mode})')

        sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)

        sm.set_array([])

        cbar = plt.colorbar(sm, ax=ax1, pad=0.02)

        cbar.set_label(colorbar_label)

        if overlay_bands_in_heat:

            for band in band_energies:

                for (s, e) in seg_ranges:

                    if e > s:

                        y = band[s:e + 1];
                        x = x_dist[s:e + 1]

                        if shift_fermi and fermi_level is not None:
                            y = y - fermi_level

                        ax1.plot(x, y, color='lightgray', lw=0.5, zorder=0)

                    else:

                        x = x_dist[s];
                        y = band[s]

                        if shift_fermi and fermi_level is not None:
                            y = y - fermi_level

                        ax1.plot(x, y, color='lightgray', lw=0.5, zorder=0)

        ax1.grid(True, ls='--', alpha=0.3)

        plt.tight_layout()
        if savefig:
            SAVE_DIR = os.path.join(SCRIPT_DIR, "saved")
            os.makedirs(SAVE_DIR, exist_ok=True)
            out = os.path.join(SAVE_DIR, os.path.basename(savefig))
            plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
            print(f"Saved figure to {out}")

        plt.show()
    elif mode in heat_modes:
        # Heatmap modes: show intensity (weight) as colored background along bands
        # Modes: 'heat_total', 'heat_atomic', 'heat_orbital', 'heat_element_orbital'
        if mode == 'heat_total':
            # sum all channels
            Wtot = np.zeros((N_k, N_e))
            for arr in W_grids:
                Wtot += arr
            heat_grid = Wtot
            heat_label = 'Total weight'
        else:
            if highlight_channel is None:
                raise ValueError(f"highlight_channel must be provided for {mode}")
            if mode == 'heat_atomic':
                unique_atoms = sorted(set(elems))
                if highlight_channel not in unique_atoms:
                    raise ValueError(f"highlight_channel '{highlight_channel}' not in atomic keys {unique_atoms}")
                Whigh = np.zeros((N_k, N_e))
                for idx, a in enumerate(elems):
                    if a == highlight_channel:
                        Whigh += W_grids[idx]
                heat_grid = Whigh
                heat_label = f"Weight of atom {highlight_channel}"
            elif mode == 'heat_orbital':
                unique_orbs = sorted(set(orbs))
                if highlight_channel not in unique_orbs:
                    raise ValueError(f"highlight_channel '{highlight_channel}' not in orbital keys {unique_orbs}")
                Whigh = np.zeros((N_k, N_e))
                for idx, o in enumerate(orbs):
                    if o == highlight_channel:
                        Whigh += W_grids[idx]
                heat_grid = Whigh
                heat_label = f"Weight of orbital {highlight_channel}"
            elif mode == 'heat_element_orbital':
                unique_eo = sorted(set(ch_labels))
                if highlight_channel not in unique_eo:
                    raise ValueError(f"highlight_channel '{highlight_channel}' not in element-orbital keys {unique_eo}")
                Whigh = np.zeros((N_k, N_e))
                for idx, lab in enumerate(ch_labels):
                    if lab == highlight_channel:
                        Whigh += W_grids[idx]
                heat_grid = Whigh
                heat_label = f"Weight of {highlight_channel}"
            else:
                raise ValueError(f"Unknown heat mode: {mode}")
        # Setup figure
        if plot_total_dos:
            if dpi is not None:
                fig, (ax1, ax2) = plt.subplots(1,2, gridspec_kw={'width_ratios':[3,1]}, figsize=(10,6), dpi=dpi, sharey=True)
            else:
                fig, (ax1, ax2) = plt.subplots(1,2, gridspec_kw={'width_ratios':[3,1]}, figsize=(10,6), sharey=True)
        else:
            if dpi is not None:
                fig, ax1 = plt.subplots(1,1,figsize=(8,6), dpi=dpi)
            else:
                fig, ax1 = plt.subplots(1,1,figsize=(8,6))
            ax2 = None
        # Flatten grid
        X_flat = np.repeat(x_dist, N_e)
        E_flat = E_grid.flatten()
        W_flat = heat_grid.flatten()
        # Color normalization
        vmin = heat_vmin if heat_vmin is not None else np.nanmin(W_flat)
        vmax = heat_vmax if heat_vmax is not None else np.nanmax(W_flat)
        norm = plt.Normalize(vmin=vmin, vmax=vmax)
        cmap = plt.get_cmap(cmap_name)
        # Plot each point as small square marker
        mask = ~np.isnan(W_flat)
        Xp = X_flat[mask]
        Ep = E_flat[mask]
        Wp = W_flat[mask]
        colors = cmap(norm(Wp))
        s_heat = (s_min + s_max) / 2.0
        ax1.scatter(Xp, Ep, s=s_heat, c=colors, marker='s', edgecolor='none', alpha=1.0, zorder=0)
        # Optionally overlay band lines
        if overlay_bands_in_heat:
            for band in band_energies:
                for (s,e) in seg_ranges:
                    if e > s:
                        y = band[s:e+1]
                        x = x_dist[s:e+1]
                        if shift_fermi and fermi_level is not None:
                            y = y - fermi_level
                        ax1.plot(x, y, color='lightgray', lw=0.5, zorder=1)
                    else:
                        x = x_dist[s]
                        y = band[s]
                        if shift_fermi and fermi_level is not None:
                            y = y - fermi_level
                        ax1.plot(x, y, 'o', color='lightgray', markersize=2, zorder=1)
        # X-ticks
        ax1.set_xticks(tick_positions)
        ax1.set_xticklabels(tick_labels)
        ax1.set_xlabel('K-point Path')
        ax1.set_ylabel('Energy (eV)')
        if y_range:
            ax1.set_ylim(y_range)
        # Title and colorbar
        mode_title = mode.replace('_',' ').title()
        ax1.set_title(f'Fatbands ({mode_title})')
        sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
        sm.set_array([])
        cbar = plt.colorbar(sm, ax=ax1, pad=0.02)
        cbar.set_label(heat_label)
        ax1.grid(True, ls='--', alpha=0.3)
        # Total DOS panel
        if plot_total_dos:
            if shift_fermi and fermi_level is not None:
                E_dos_plot = E_dos
            else:
                E_dos_plot = E_dos
            ax2.plot(DOS, E_dos_plot, 'k-', lw=1)
            ax2.set_xlabel('DOS')
            if y_range:
                ax2.set_ylim(y_range)
            ax2.axvline(0, color='gray', ls='--', lw=0.8)
            ax2.grid(True, ls='--', alpha=0.3)
        plt.tight_layout()
        if savefig:
            SAVE_DIR = os.path.join(SCRIPT_DIR, "saved")
            os.makedirs(SAVE_DIR, exist_ok=True)
            out = os.path.join(SAVE_DIR, os.path.basename(savefig))
            plt.savefig(out, dpi=dpi or plt.rcParams['figure.dpi'])
            print(f"Saved figure to {out}")

        plt.show()

    else:
        raise ValueError(f"Unknown fatbands mode: {mode}")

# ==============================
# MAIN ENTRYPOINT
# ==============================

def plot_from_file(
    plot_type='band',
    pdos_dir=None,
    fatband_dir=None,
    kpath_file=None,
    band_file=None,
    dos_file=None,
    pdos_mode='atomic',
    fatbands_mode='most',
    highlight_channel=None,
    dual=False,
    band_mode='normal',
    cmap_name='tab10',
    s_min=10,
    s_max=100,
    weight_threshold=0.01,
    y_range=None,
    fermi_level=None,
    shift_fermi=False,
    plot_total_dos=False,
    overlay_bands_in_heat=False,
    heat_vmin=None,
    heat_vmax=None,
    dpi=None,
    layer_assignment=None,
        savefig=None

):
    """
        High-level wrapper for plotting Quantum ESPRESSO band, DOS, PDOS, and fatbands in one function.

        This function lets you plot a band structure, total DOS, projected DOS (PDOS), or fatbands
        simply by specifying the plot type and relevant file paths.
        It automatically calls the correct plot function with all the necessary arguments.

        Parameters
        ----------
        plot_type : str, optional
            What kind of plot to produce. Must be one of:
                - 'band': electronic band structure
                - 'dos': total density of states
                - 'pdos': projected density of states
                - 'fatbands': fatband plot (atom/orbital-resolved bands)
        pdos_dir : str, optional
            Directory containing PDOS files (required for 'pdos' and optionally for 'fatbands').
        fatband_dir : str, optional
            Directory containing fatband/projwfc files (required for 'fatbands').
        kpath_file : str, optional
            Path to the K_POINTS (crystal_b) file for band structure plots.
        band_file : str, optional
            Path to the QE band structure file (.bands.dat.gnu).
        dos_file : str, optional
            Path to the total DOS file (columns: energy, DOS).
        pdos_mode : str, optional
            PDOS plot grouping mode ('atomic', 'orbital', or 'element_orbital').
        fatbands_mode : str, optional
            Fatband plot mode ('most', 'atomic', 'orbital', 'element_orbital', etc.).
        highlight_channel : str or list, optional
            Channel(s) to highlight for line or heatmap fatband modes.
        dual : bool, optional
            If True, compare two highlight channels in line fatband modes.
        band_mode : str, optional
            Band plot style (see plot_band docstring).
        cmap_name : str, optional
            Name of the matplotlib colormap.
        s_min, s_max : float, optional
            Min/max marker size for bubble/heatmap modes.
        weight_threshold : float, optional
            Threshold for displaying small weights (fatbands).
        y_range : tuple or list, optional
            (ymin, ymax) for energy axis.
        fermi_level : float, optional
            Fermi energy (eV). Used for shifting plots if desired.
        shift_fermi : bool, optional
            If True, shifts the Fermi level to 0 eV in plots.
        plot_total_dos : bool, optional
            If True, plots total DOS alongside fatbands.
        overlay_bands_in_heat : bool, optional
            If True, overlays band lines on heatmap fatbands.
        heat_vmin, heat_vmax : float, optional
            Min/max for heatmap normalization.
        dpi : int, optional
            Output resolution for the plot.
        layer_assignment : dict, optional
            For 'layer' fatband mode, maps atoms to 'top'/'bottom' layers.
        savefig : str, optional
            Filename for saving the plot (inside the 'saved' folder). If None, plot is only displayed.

        Returns
        -------
        None. Calls the appropriate plot function, which shows and/or saves the plot.

        Examples
        --------
        # Plot band structure:
        plot_from_file(plot_type='band', band_file='bands.dat.gnu', kpath_file='kpath.in')

        # Plot total DOS:
        plot_from_file(plot_type='dos', dos_file='dos.dat')

        # Plot atom-projected PDOS:
        plot_from_file(plot_type='pdos', pdos_dir='pdos/', pdos_mode='atomic')

        # Plot fatbands by atomic species:
        plot_from_file(
            plot_type='fatbands',
            band_file='bands.dat.gnu',
            fatband_dir='fatbands/',
            kpath_file='kpath.in',
            fatbands_mode='atomic',
            savefig='fatbands_by_atom.pdf'
        )
        """







    pt = plot_type.lower()
    if pt == 'band':
        plot_band(
            band_file=band_file,
            kpath_file=kpath_file,
            fermi_level=fermi_level,
            shift_fermi=shift_fermi,
            y_range=y_range,
            dpi=dpi,
            band_mode=band_mode,
            fatband_dir=fatband_dir,
            cmap_name=cmap_name,
        savefig=savefig
        )
    elif pt == 'dos':
        plot_dos(dos_file, fermi_level, shift_fermi, y_range, dpi=dpi,
        savefig=savefig)
    elif pt == 'pdos':
        plot_pdos_dir(pdos_dir, fermi_level, shift_fermi, y_range, dpi=dpi,pdos_mode=pdos_mode,
        savefig=savefig)
    elif pt == 'fatbands':
        fb_dir = fatband_dir if fatband_dir is not None else pdos_dir
        if fb_dir is None or band_file is None or kpath_file is None:
            raise ValueError("fatband_dir (or file_path), band_file, and kpath_file are all required for 'fatbands'")
        plot_fatbands(
            directory=fb_dir,
            kpath_file=kpath_file,
            band_file=band_file,
            mode=fatbands_mode,
            highlight_channel=highlight_channel,
            dual=dual,
            fermi_level=fermi_level,
            shift_fermi=shift_fermi,
            y_range=y_range,
            cmap_name=cmap_name,
            s_min=s_min,
            s_max=s_max,
            weight_threshold=weight_threshold,
            plot_total_dos=plot_total_dos,
            dos_file=dos_file,
            overlay_bands_in_heat=overlay_bands_in_heat,
            heat_vmin=heat_vmin,
            heat_vmax=heat_vmax,
            dpi=dpi,
            layer_assignment=layer_assignment,
        savefig=savefig  # <--- PASSED DOWN
        )
    else:
        raise ValueError("Use 'band','dos','pdos', or 'fatbands' for plot_type")